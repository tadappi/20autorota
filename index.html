<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>20autorota — three.js viewer (sRGB + Shadow + GUI)</title>
  <style>
    html,body{height:100%;margin:0}
    #app{position:fixed;inset:0;background:#0b0e13}
    canvas{display:block}
    .hint{
      position:fixed;left:10px;bottom:10px;color:#cfd8dc;
      font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      opacity:.85;user-select:none;background:rgba(0,0,0,.35);
      padding:6px 8px;border-radius:6px
    }
  </style>

  <!-- ✅ Import Map：'three' という裸の識別子をURLに解決 -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<div id="app"></div>
<div class="hint">マウス：左=回転 / 中=パン / ホイール=ズーム　｜　GUIで光・自動回転を調整</div>

<!-- ✅ 以降はESMで読み込み。examples側は内部で 'three' をimportするが、上のimport mapで解決される -->
<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
  import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

  // ----------------------------------------
  // 基本セットアップ
  // ----------------------------------------
  const container = document.getElementById('app');

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace; // ★超重要：発色＆コントラスト
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0e13);

  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 5000);
  camera.position.set(0, 40, 80);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.autoRotate = true;        // autorota らしく既定ON
  controls.autoRotateSpeed = 0.5;
  controls.target.set(0, 0, 0);

// === Raycaster & state ===
const raycaster = new THREE.Raycaster();
const mouseNDC = new THREE.Vector2();

let hoverObject = null;        // いまホバー中の対象
const clickableObjects = [];   // クリック判定対象（ピン、エリア等）

// マウス座標更新
renderer.domElement.addEventListener('pointermove', (e)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouseNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
});

// クリック
renderer.domElement.addEventListener('click', ()=>{
  if (!hoverObject) return;
  const url = hoverObject.userData?.url;
  if (url) window.open(url, '_blank');
});







  
  // ----------------------------------------
  // 光
  // ----------------------------------------
  const ambient = new THREE.AmbientLight(0xffffff, 2.0);
  scene.add(ambient);

  const sun = new THREE.DirectionalLight(0xffffff, 1.0);
  sun.position.set(3, 5, 2).multiplyScalar(100);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.near = 10;
  sun.shadow.camera.far = 1000;
  sun.shadow.camera.left = -300;
  sun.shadow.camera.right = 300;
  sun.shadow.camera.top = 300;
  sun.shadow.camera.bottom = -300;
  scene.add(sun);

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(4000, 4000),
    new THREE.ShadowMaterial({ opacity: 0.25 })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.01;
  ground.receiveShadow = true;
  ground.visible = false; // 必要時GUIでON
  scene.add(ground);

  // ----------------------------------------
  // モデル読込
  // ----------------------------------------
  const loader = new GLTFLoader();
  let root = null;

  loader.load('./20.glb', (gltf) => {
    root = gltf.scene;
    root.traverse((o) => {
      if (o.isMesh) {
        o.castShadow = true;
        o.receiveShadow = false; // 必要なら true
      }
    });
    scene.add(root);

// === Axes Helper（3軸） ===
const axes = new THREE.AxesHelper(100); // 数字は軸の長さ
axes.visible = true;                    // とりあえず表示ON
scene.add(axes);

    
    // フィット
    const box = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3(), center = new THREE.Vector3();
    box.getSize(size); box.getCenter(center);
    root.position.sub(center);

    const maxDim = Math.max(size.x, size.y, size.z);
    const dist = maxDim * 1.6;
    camera.position.set(dist * 0.3, dist * 0.2, dist * 0.3);// カメラの位置モデルサイズに乗じてる
    controls.target.set(0, 0, 0);
    controls.update();
  }, undefined, (err) => {
    console.error(err);
    alert('GLBの読み込みに失敗しました。パスやファイル名を確認してください。');
  });


// ========= その1：ピン =========
const pin = createPin({
  pos: [10, 8, -5],                      // ★位置はあとで調整（モデル原点基準）
  url: 'https://dazaifu.org/dazaifu-seicho-ato/',
  iconBlue: './pin1blue.png',
  iconRed:  './pin1red.png',
  labelPng: './seicho.png',
  scale: 10                              // ピンの大きさ（メートル換算のつもりで調整）
});
root.add(pin);
clickableObjects.push(pin);

// ========= その2：エリア =========
const { trigger: areaTrigger, fx: areaFx } = createHoverArea({
  center: [60, 6, -30],                  // ★中心座標（あとで調整）
  size:   [80, 12, 60],                  // ★幅x高さx奥行（あとで調整）
  url: 'https://oki-park.jp/shurijo/guide/51',
  color: 0x2a6cff
});
root.add(areaTrigger);
root.add(areaFx);
clickableObjects.push(areaTrigger);

// 調整しやすいよう、目視用ヘルパー（任意）
// const h1 = new THREE.Box3Helper(new THREE.Box3().setFromObject(areaTrigger), 0x0077ff);
// scene.add(h1);





  

  // ----------------------------------------
  // GUI
  // ----------------------------------------
  const gui = new GUI({ title: 'Controls' });
  const params = {
    background: '#0b0e13',
    ambientIntensity: ambient.intensity,
    sunIntensity: sun.intensity,
    sunElevDeg: 35,
    sunAziDeg: 25,
    autoRotate: controls.autoRotate,
    rotateSpeed: controls.autoRotateSpeed,
    showGroundShadow: ground.visible,
    rotateX: -92, rotateY: 0, rotateZ: -8
  };

  function updateSunFromAngles(){
    const elev = THREE.MathUtils.degToRad(params.sunElevDeg);
    const azi  = THREE.MathUtils.degToRad(params.sunAziDeg);
    const r = 100;
    sun.position.set(
      r * Math.cos(elev) * Math.cos(azi),
      r * Math.sin(elev),
      r * Math.cos(elev) * Math.sin(azi)
    );
  }
  updateSunFromAngles();

  gui.addColor(params, 'background').name('Background').onChange(v=>{
    scene.background = new THREE.Color(v);
  });

  const fLight = gui.addFolder('Lighting');
  fLight.add(params, 'ambientIntensity', 0, 1.5, 0.01).name('Ambient').onChange(v=>{
    ambient.intensity = v;
  });
  fLight.add(params, 'sunIntensity', 0, 2.5, 0.01).name('Sun').onChange(v=>{
    sun.intensity = v;
  });
  fLight.add(params, 'sunElevDeg', 0, 90, 1).name('Sun Elev [deg]').onChange(updateSunFromAngles);
  fLight.add(params, 'sunAziDeg', -180, 180, 1).name('Sun Azi [deg]').onChange(updateSunFromAngles);
  fLight.add(params, 'showGroundShadow').name('Ground shadow').onChange(v=>{
    ground.visible = v;
  });

  const fModel = gui.addFolder('Model Rotation');
  fModel.add(params, 'rotateX', -180, 180, 1).name('Rotate X [deg]');
  fModel.add(params, 'rotateY', -180, 180, 1).name('Rotate Y [deg]');
  fModel.add(params, 'rotateZ', -180, 180, 1).name('Rotate Z [deg]');

  const fView = gui.addFolder('View');
  fView.add(params, 'autoRotate').name('Auto rotate').onChange(v=>{
    controls.autoRotate = v;
  });
  fView.add(params, 'rotateSpeed', -3, 3, 0.1).name('Rotate speed').onChange(v=>{
    controls.autoRotateSpeed = v;
  });


// ========== その1：ピン（Sprite） ==========
function createPin({ pos=[0,0,0], url, iconBlue, iconRed, labelPng, scale=10 }) {
  const texBlue = new THREE.TextureLoader().load(iconBlue);
  const texRed  = new THREE.TextureLoader().load(iconRed);
  const texLabel= labelPng ? new THREE.TextureLoader().load(labelPng) : null;

  const matBlue = new THREE.SpriteMaterial({ map: texBlue, transparent: true });
  const matRed  = new THREE.SpriteMaterial({ map: texRed,  transparent: true });

  const pin = new THREE.Sprite(matBlue);
  pin.position.set(...pos);
  pin.scale.setScalar(scale);
  pin.renderOrder = 10; // 前面に出したいとき

  pin.userData = {
    url,
    type: 'pin',
    mats: { blue: matBlue, red: matRed },
    label: null
  };

  // ラベル（Sprite）— ホバー時だけ表示
  if (texLabel) {
    const matLabel = new THREE.SpriteMaterial({ map: texLabel, transparent: true, depthTest: true });
    const label = new THREE.Sprite(matLabel);
    label.scale.setScalar(scale * 2.0);  // 好みで
    label.position.set(0, scale * 1.4, 0); // ピンの上に
    label.visible = false;
    pin.add(label);
    pin.userData.label = label;
  }
  return pin;
}

// ========== その2：エリア（Invisible Trigger + Effect Box） ==========
function createHoverArea({ center=[0,0,0], size=[30,10,30], url, color=0x2a6cff }) {
  // ヒット判定用（見えない箱）
  const triggerMat = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.0, transparent: true });
  const trigger = new THREE.Mesh(new THREE.BoxGeometry(...size), triggerMat);
  trigger.position.set(...center);
  trigger.userData = { url, type:'area' };

  // 見えるエフェクト（半透明箱）— ホバー時のみ表示＆浮遊アニメ
  const fxMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.35, depthWrite: false });
  const fx = new THREE.Mesh(new THREE.BoxGeometry(size[0]*1.02, size[1], size[2]*1.02), fxMat);
  fx.position.set(...center);
  fx.visible = false;             // ホバー時のみ表示
  fx.userData = { baseY: center[1], t: 0 };

  return { trigger, fx };
}









  
  // ----------------------------------------
  // ループ
  // ----------------------------------------
  const clock = new THREE.Clock();


function tick(){
  // --- レイキャスト（ホバー判定） ---
  raycaster.setFromCamera(mouseNDC, camera);
  const hits = raycaster.intersectObjects(clickableObjects, true); // 子もOK
  const hit = hits.length ? (hits[0].object.userData.type === 'pin' ? hits[0].object : hits[0].object.parent?.userData?.type==='pin' ? hits[0].object.parent : hits[0].object) : null;

  // 前フレームと違う対象にホバーしたら切替
  if (hoverObject !== hit) {
    // 既存のホバー解除
    if (hoverObject) {
      if (hoverObject.userData.type === 'pin') {
        hoverObject.material = hoverObject.userData.mats.blue;
        if (hoverObject.userData.label) hoverObject.userData.label.visible = false;
      } else if (hoverObject.userData.type === 'area') {
        // 何もしない（エフェクトは下で処理）
      }
    }
    hoverObject = hit;
    // 新しくホバー
    if (hoverObject) {
      if (hoverObject.userData.type === 'pin') {
        hoverObject.material = hoverObject.userData.mats.red;
        if (hoverObject.userData.label) hoverObject.userData.label.visible = true;
      }
    }
    // マウスカーソル形状
    renderer.domElement.style.cursor = hoverObject ? 'pointer' : 'default';
  }

  // --- その2の浮遊エフェクト（ホバー時のみ可視＆上下にフワッ） ---
  if (hoverObject && hoverObject.userData.type === 'area') {
    areaFx.visible = true;
    areaFx.userData.t += 0.03; // 速度
    const yOff = Math.sin(areaFx.userData.t) * 4; // 上下量
    areaFx.position.y = areaFx.userData.baseY + yOff;
    areaFx.material.opacity = 0.35 * (0.6 + 0.4 * Math.cos(areaFx.userData.t)); // うっすら明滅
  } else {
    areaFx.visible = false;
    areaFx.userData.t = 0;
    areaFx.position.y = areaFx.userData.baseY;
    areaFx.material.opacity = 0.35;
  }

  // --- 既存：モデル回転＆描画 ---
  if (root){
    root.rotation.set(
      THREE.MathUtils.degToRad(params.rotateX),
      THREE.MathUtils.degToRad(params.rotateY),
      THREE.MathUtils.degToRad(params.rotateZ)
    );
  }
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
  tick();

  // リサイズ
  window.addEventListener('resize', ()=>{
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>
</body>
</html>









